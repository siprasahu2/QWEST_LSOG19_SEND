[condition][]xcb object=xcb : XOMContainerBean()
[condition][]Evaluate=eval
[condition][]it is not true that the field_tag {field} is exists=(!xcb.xpath({field}).booleanValue())
[condition][]it is not true that the {field} is populated=(!((new Populated()).isPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that the {field} is not populated=(!((new Populated()).isNotPopulated(xcb.xpath({field}).stringValue())))
[condition][]it is not true that the {field} equals {value}=(!((new Equals()).isEquals(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {field} equals {value}=((new Equals()).isEquals(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that the {field} is equal to values {values}=(!((new Equals()).isEqualToValues((xcb.xpath({field}).stringValue()),{values})))
[condition][]the {field} is equal to values {values}=((new Equals()).isEqualToValues((xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_the {field} is equal to values {values}=(!((new Equals()).isEqualToValues((xcb.xpath({field}).stringValue()),{values})))
[condition][]the {field} is not equal to values {values}=((new Equals()).isNotEqualToValues((xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_the maximum length of {field} is {value}=(!((new LengthCheck()).checkMaximumlength(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the maximum length of {field} is {value}=((new LengthCheck()).checkMaximumlength(((xcb.xpath({field})).stringValue()),{value}))
[condition][]the {field} is AlphaNumeric without following Special Character set {value}=((new DatatypeCheck()).checkAlphaNumericWithOutSPSet(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} is AlphaNumeric without following Special Character set {value}=(!((new DatatypeCheck()).checkAlphaNumericWithOutSPSet(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {pos} position of {field} is equal to {value}=((new Position()).positionOftagValueEqualToValue({pos}, ((xcb.xpath({field}).stringValue())), {value}))
[condition][]it is not true that_the {pos} position of {field} is equal to {value}=(!((new Position()).positionOftagValueEqualToValue({pos}, ((xcb.xpath({field}).stringValue())), {value})))
[condition][]the {pos} position of {field} is not equal to {value}=(!((new Position()).positionOftagValueEqualToValue({pos}, ((xcb.xpath({field}).stringValue())), {value})))
[condition][]the {field} has telephone number format as {format}=((new TNFormat()).tnFormatIs((xcb.xpath({field}).stringValue()), {format}))
[condition][]it is not true that_the {field} has telephone number format as {format}=(!((new TNFormat()).tnFormatIs((xcb.xpath({field}).stringValue()), {format})))
[condition][]the length of {field} is {value}=((new LengthCheck()).checkLength((xcb.xpath({field}).stringValue()), {value}))
[condition][]it is not true that_the length of {field} is {value}=(!((new LengthCheck()).checkLength((xcb.xpath({field}).stringValue()), {value})))
[condition][]the {field} is Numeric=((new DatatypeCheck()).checkNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is Numeric=(!((new DatatypeCheck()).checkNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {field} is greater than {value}=((new Equals()).isGreaterThan((xcb.xpath({field}).stringValue()), {value}))
[condition][]it is not true that_the {field} is greater than {value}=(!((new Equals()).isGreaterThan((xcb.xpath({field}).stringValue()), {value})))
[condition][]the {field} contains {values}=((new Contains()).contains((xcb.xpath({field}).stringValue()), {values}))
[condition][]it is not true that_the {field} contains {values}=(!((new Contains()).contains((xcb.xpath({field}).stringValue()), {values})))
[condition][]the {field} has a character {char} followed and preceeded by a numeric=((new Contains()).characterPreceededOrFollowedByNumeric((xcb.xpath({field}).stringValue()),{char}))
[condition][]it is not true that_the {field} has a character {char} followed and preceeded by a numeric=(!((new Contains()).characterPreceededOrFollowedByNumeric((xcb.xpath({field}).stringValue()),{char})))
[condition][]the {field} is AlphaNumeric=((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is AlphaNumeric=(!((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {field} is AlphaNumeric_with following Special Character set {values}=((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field}).stringValue()), {values}))
[condition][]it is not true that_the {field} is AlphaNumeric_with following Special Character set {values}=(!((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field}).stringValue()), {values})))
[condition][]the {field} is Alpha=((new DatatypeCheck()).checkAlpha((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is Alpha=(!((new DatatypeCheck()).checkAlpha((xcb.xpath({field}).stringValue()))))
[condition][]the position of Alpha is {pos} in {field}=((new DatatypeCheck()).checkPositionAlpha({pos}, (xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the position of Alpha is {pos} in {field}=(!((new DatatypeCheck()).checkPositionAlpha({pos}, (xcb.xpath({field}).stringValue()))))
[condition][]the {pos} position of {field} is not_equal to values {values}=((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_the {pos} position of {field} is not_equal to values {values}=(!((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field}).stringValue()),{values})))
[condition][]Positions {pos1} and {pos2} of {field} is equal to values {values}=((new Position()).twoPositionValueofTagEqualToValues({pos1}, {pos2}, ((xcb.xpath({field}).stringValue())), {values}))
[condition][]it is not true that_Positions {pos1} and {pos2} of {field} is equal to values {values}=(!((new Position()).twoPositionValueofTagEqualToValues({pos1}, {pos2}, ((xcb.xpath({field}).stringValue())), {values})))
[condition][]the {field} is compared with its position {pos1} to {pos2} with values {values}=((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field}).stringValue()), {pos1}, {pos2}, {values}))
[condition][]it is not true that_the {field} is compared with its position {pos1} to {pos2} with values {values}=(!((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field}).stringValue()), {pos1}, {pos2}, {values})))
[condition][]the field {field} contain character {char} followed by space=((new Contains()).characterFollowedBySpace((xcb.xpath({field}).stringValue()),{char}))
[condition][]it is not true that_the field {field} contain character {char} followed by space=(!((new Contains()).characterFollowedBySpace((xcb.xpath({field}).stringValue()),{char})))
[condition][]the {field} contains_double virgule and not preceeded and followed by alphanumeric=((new Contains()).doubleVirgleNotPreceededAndFollowedByAlphaNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains_double virgule and not preceeded and followed by alphanumeric=(!((new Contains()).doubleVirgleNotPreceededAndFollowedByAlphaNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {field} contains_ampersand preceded by a space=((new SpaceCheck()).isAmpersandprecspace((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains_ampersand preceded by a space=(!((new SpaceCheck()).isAmpersandprecspace((xcb.xpath({field}).stringValue()))))
[condition][]the {field1} not_equals to the {field2}=((new Equals()).isNotEquals((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue())))
[condition][]it is not true that_the {field1} not_equals to the {field2}=(!((new Equals()).isNotEquals((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()))))
[condition][]the {field} contains_single paranthesis and not contained in another parenthesis=((new Contains()).checkSingleParanthesis((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains single paranthesis and not contained in another parenthesis=(!((new Contains()).checkSingleParanthesis((xcb.xpath({field}).stringValue()))))
[condition][]virguleFollowedByVirgule {field}=((new Contains()).virguleFollowedByVirgule((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_virguleFollowedByVirgule{field}=(!((new Contains()).virguleFollowedByVirgule((xcb.xpath({field}).stringValue()))))
[condition][]the {field} contains_consecutive spaces=((new Contains()).spaceFollowedBySpace((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains_consecutive spaces=(!((new Contains()).spaceFollowedBySpace((xcb.xpath({field}).stringValue()))))
[condition][]characterPreceededAndFollowedByAlpha with {field} and {char}=((new Contains()).characterPreceededAndFollowedByAlpha(xcb.xpath({field}).stringValue(),{char}))
[condition][]it is not true that_characterPreceededAndFollowedByAlpha with {field} and {char}=(!((new Contains()).characterPreceededAndFollowedByAlpha(xcb.xpath({field}).stringValue(),{char})))
[condition][]characterPreceededAndFollowedByAlphaNumeric with {field} and {char}=((new Contains()).characterPreceededAndFollowedByAlphaNumeric(xcb.xpath({field}).stringValue(),{char}))
[condition][]it is not true that_characterPreceededAndFollowedByAlphaNumeric with {field} and {char}=(!((new Contains()).characterPreceededAndFollowedByAlphaNumeric(xcb.xpath({field}).stringValue(),{char})))
[condition][]characterFollowedByAlpha with {field} and {char}=((new Contains()).characterFollowedByAlpha(xcb.xpath({field}).stringValue(),{char}))
[condition][]it is not true that_characterFollowedByAlpha with {field} and {char}=(!((new Contains()).characterFollowedByAlpha(xcb.xpath({field}).stringValue(),{char})))
[condition][]twoAdjacentCharactersPreceededAndFollowedByAlpha with {field} and {char}=((new Contains()).twoAdjacentCharactersPreceededAndFollowedByAlpha(xcb.xpath({field}).stringValue(),{char}))
[condition][]it is not true that_twoAdjacentCharactersPreceededAndFollowedByAlpha with {field} and {char}=(!((new Contains()).twoAdjacentCharactersPreceededAndFollowedByAlpha(xcb.xpath({field}).stringValue(),{char})))
[condition][]Position {pos} of {field} field is equal to values {values}=((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_Position {pos} of {field} field is equal to values {values}=(!((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field}).stringValue()),{values})))
[condition][]there is no {section} section=(xcb.xpath({section}).stringValue().length() == 0)
[condition][]it is not true that_there is no {section} section=(!(xcb.xpath({section}).stringValue().length() == 0))
[condition][]the {field}is Alpha_with Special Characters Set {values}=((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_the {field}is Alpha_with Special Characters Set {values}=(!((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field}).stringValue()),{values})))
[condition][]the position {pos1} and {pos2} of {field} is between {val1} and {val2}=((new RangeOfValues()).twoFieldPositionInRange({pos1}, {pos2}, (xcb.xpath({field}).stringValue()),{val1}, {val2}))
[condition][]it is not true that_the position {pos1} and {pos2} of {field} is between {val1} and {val2}=(!((new RangeOfValues()).twoFieldPositionInRange({pos1}, {pos2}, (xcb.xpath({field}).stringValue()),{val1}, {val2})))
[condition][]the {field} is prohibited=((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} is prohibited=((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue()))
[condition][]the {field} is Numeric_with Special Characters Set {value}=((new DatatypeCheck()).checkNumericSPSet(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} is Numeric_with Special Characters Set {value}=(!((new DatatypeCheck()).checkNumericSPSet(((xcb.xpath({field})).stringValue()),{value})))
[condition][]Is the {field1} less than {field2} in the format {format}=((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()),{format}))
[condition][]it is not true that_Is the {field1} less than {field2} in the format {format}=(!((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()),{format})))
[condition][]the values at position {pos11} to {pos12} of {field1} equals values at {pos21} to {pos22} of {field2}=((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos11}, {pos12}, (xcb.xpath({field1}).stringValue()), {pos21}, {pos22}, (xcb.xpath({field2}).stringValue())))
[condition][]it is not true that_the values at position {pos11} to {pos12} of {field1} equals values at {pos21} to {pos22} of {field2}=(!((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos11}, {pos12}, (xcb.xpath({field1}).stringValue()), {pos21}, {pos22},(xcb.xpath({field2}).stringValue()))))
[condition][]the length of {field} is_between {value1} and {value2}=((new LengthCheck()).checkMinMaxLength((xcb.xpath({field}).stringValue()), {value1}, {value2}))
[condition][]it is not true that_the length of {field} is_between {value1} and {value2}=(!((new LengthCheck()).checkMinMaxLength((xcb.xpath({field}).stringValue()), {value1}, {value2})))
[condition][]lastCharPositionNotNumeric for the field {field}=((new DatatypeCheck()).lastCharPositionNotNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_lastCharPositionNotNumeric for the field {field}=(!((new DatatypeCheck()).lastCharPositionNotNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {field} is not required=((new Required()).isNotRequired((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is not required=(!((new Required()).isNotRequired((xcb.xpath({field}).stringValue()))))
[condition][]the {field} has all uppercase characters=((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} has all uppercase characters=(!((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field}).stringValue()))))
[condition][]the {field} has time format as {format}=((new TimeFormatCheck()).timeFormat((xcb.xpath({field}).stringValue()), {format}))
[condition][]it is not true that_the {field} has time format as {format}=(!((new TimeFormatCheck()).timeFormat((xcb.xpath({field}).stringValue()), {format})))
[condition][]three character range {range1} to {range2} of the {field} is not_populated or blank=((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field}).stringValue()), {range1}, {range2}))
[condition][]it is not true that_three character range {range1} to {range2} of the {field} is not_populated or blank=(!((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field}).stringValue()), {range1}, {range2})))
[condition][]the {field} has the date format as {format}=((new DateFormatCheck()).dateCheck((xcb.xpath({field}).stringValue()), {format}))
[condition][]it is not true that_the {field} has the date format as {format}=(!((new DateFormatCheck()).dateCheck((xcb.xpath({field}).stringValue()), {format})))
[condition][]the {field} is_according to the specified {format}=((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field}).stringValue()), {format}))
[condition][]it is not true that_the {field} is_according to the specified {format}=(!((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field}).stringValue()), {format})))
[condition][]the {field} is AlphaNumeric_with only space as special character=((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is AlphaNumeric_with only space as special character=(!((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field}).stringValue()))))
[condition][]the {field} contains_numeric characters=((new Contains()).containsNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains_numeric characters=(!((new Contains()).containsNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {pos1} to {pos2} position of the {field} is less than or equal to {pos3} to {pos4} position=((new Position()).posToPosOfTagIsLessThanOrEqualToPosToPos({pos1}, {pos2}, (xcb.xpath({field}).stringValue()),{pos3}, {pos4}))
[condition][]it is not true that_the {pos1} to {pos2} position of the {field} is less than or equal to {pos3} to {pos4} position=(!((new Position()).posToPosOfTagIsLessThanOrEqualToPosToPos({pos1}, {pos2}, (xcb.xpath({field}).stringValue()),{pos3}, {pos4})))
[condition][]the {field1} is_less than {field2}=((new DateCheck()).isLessThan((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue())))
[condition][]it is not true that_the {field1} is_less than {field2}=(!((new DateCheck()).isLessThan((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()))))
[condition][]the {field} is_equal_or_greater than {value}=((new Equals()).isEqualOrGreaterThan(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} is_equal_or_greater than {value}=(!((new Equals()).isEqualOrGreaterThan(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {field} is_equal_or_less than {value}=((new Equals()).isEqualOrLessThan(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} is_equal_or_less than {value}=(!((new Equals()).isEqualOrLessThan(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {field} has format as {value}=((new SpecialFormat()).formatIs(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} has format as {value}=(!((new SpecialFormat()).formatIs(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {field} is required=((new Required()).isRequired((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} is required=(!((new Required()).isRequired((xcb.xpath({field})).stringValue())))
[consequence][]the error code {errorCode} with message {errorMsg} for the field {xPath}=xcb.logError({errorCode},{errorMsg},{xPath})
[consequence][]execute the rule=
[condition][]the {field} not preceeded and followed by {char}=((new Contains()).characterNotPreceededAndFollowedByNumeric((xcb.xpath({field}).stringValue()), {char}))
[condition][]it is not true that_the {field} not preceeded and followed by {char}=(!((new Contains()).characterNotPreceededAndFollowedByNumeric((xcb.xpath({field}).stringValue()), {char})))
[condition][]it is not true that_the occurance of {field} is equal to {count}=(NumOccOfSecNotEqualCount(xcb,{field},{count}))
[condition][]it is not true that_the value of {field1} is equal to number of occurance of {field2} in section {section}=(NumOccOfSecNotEqualFieldValue(xcb,{field1},{field2},{section}))
[condition][]any occurence of {field} in {section} are not populated=(AllOccOfFieldNotPop(xcb,{field},{section}))
[condition][]Difference between pos 14-17 and pos 9-12 of {field} across the order_is greater than {num}=(countPortedNbrRangeformatvalues(xcb,{field},{num}))
[condition][]Check PIA Response for {field1} and {field2}=FunGetResponseXMLForResponseType(xcb,{field1},{field2})
[condition][]Check cancel Order for {field1} and {field2}=FunCancelOrderCheck(xcb,{field1},{field2})
[consequence][]the rule {ruleId} with error code {errorCode} with message {errorMsg} for the field {field} of section {section}=logMultipleError(xcb,{ruleId},{section},{field},{errorCode},{errorMsg})
[condition][]Rule {ruleID} multiple times {field} in {section} is populated=(moExists(xcb,{ruleID},{section},{field}))
[condition][]Rule {ruleID} multiple times {field} in {section} is_not populated=(moNotExists(xcb,{ruleID},{section},{field}))
[condition][]Rule {ruleID} multiple times {field} in {section} maximum length value {value}=(moMaxLength(xcb,{ruleID},{section},{field},{value}))
[condition][]Rule {ruleID} multiple times {field} in {section} is equal to {values}=(multiEquals(xcb,{ruleID},{section},{field},{values}))
[condition][]Rule {ruleID} multiple times {field} in {section} is not equal to {values}=((multiNotEquals(xcb,{ruleID},{section},{field},{values})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is Alpha_with Special Characters Set {values}=((AlphaSpecialChar(xcb,{ruleID},{section},{field},{values})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is Alpha=((isNotAlpha(xcb,{ruleID},{section},{field})))
[condition][]Rule {ruleID} multiple times {field} in {section} is Alpha=((isAlpha(xcb,{ruleID},{section},{field})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is Numeric=((isNotNumber(xcb,{ruleID},{section},{field})))
[condition][]Rule {ruleID} multiple times {field} in {section} is Numeric=((isNumber(xcb,{ruleID},{section},{field})))
[condition][]Rule {ruleID} multiple times_the {pos} position of {field} in {section} is not equal to values {values}=(PositionValue(xcb,{ruleID},{section},{field},{pos},{values}))
[condition][]Rule {ruleID} multiple times_the {field} in {section} is greater than {value}=(isGreaterThan(xcb,{ruleID},{section},{field},{value}))
[condition][]Rule {ruleID} multiple times_the {pos} position of {field} in {section} is equal to values {values}=(PositionValueEqual(xcb,{ruleID},{section},{field},{pos},{values}))
[condition][]it is not true that_Rule {ruleID} multiple times_position {pos1} and {pos2} of {field} in {section} is between {val1} and {val2}=(Positions1n2Values(xcb,{ruleID},{section},{field},{pos1},{pos2},{val1},{val2}))
[condition][]the {pos1} to {pos2} position of Rule {ruleID} multiple times {field} in {section} is less than or equal to {pos3} to {pos4} position=(posToPosOfTagIsLessThanOrEqualToPosToPos(xcb,{ruleID},{section},{field},{pos1},{pos2},{pos3},{pos4}))
[condition][]Rule {ruleID} multiple times {field} in {section} is AlphaNumeric=((isAlphaNumeric(xcb,{ruleID},{section},{field})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is AlphaNumeric=((isNotAlphaNumeric(xcb,{ruleID},{section},{field})))
[condition][]it is not true that_Rule {ruleID} multiple times_length of {field} in {section} is {value}=((LengthNotValue(xcb,{ruleID},{section},{field},{value})))
[condition][]Rule {ruleID} multiple times_length of {field} in {section} is {value}=((LengthValue(xcb,{ruleID},{section},{field},{value})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} has telephone number format as {format}=((TelNumFormat(xcb,{ruleID},{section},{field},{format})))
[condition][]it is not true that_Rule {ruleID} multiple times {field1} in {section} is greater than_or_equal to {field2}=((F1greaterThanF2(xcb,{ruleID},{section},{field1},{field2})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is AlphaNumeric_without following Special Character set {values}=((AlphaNumSpecialChar(xcb,{ruleID},{section},{field},{values})))
[condition][]Rule {ruleID} multiple times {field} in {section} is AlphaNumeric_without following Special Character set {values}=((AlphaNumNotSpecialChar(xcb,{ruleID},{section},{field},{values})))
[condition][]it is not true that_Rule {ruleID} multiple times_the {field} in {section} has a character {char} followed and preceeded by a numeric=(characterPreceededOrFollowedByNumeric(xcb,{ruleID},{section},{field},{char}))
[condition][]Rule {ruleID} multiple times_the {field} in {section} contains {values}=(containsfun(xcb,{ruleID},{section},{field},{values}))
[condition][]it is not true that_Rule {ruleID} multiple times_characterFollowedByAlpha with {field} in {section} and {char}=(characterFollowedByAlpha(xcb,{ruleID},{section},{field},{char}))
[condition][]Rule {ruleID} multiple times_characterPreceededAndFollowedByAlpha with {field} in {section} and {char}=(characterPreceededAndFollowedByAlpha(xcb,{ruleID},{section},{field},{char}))
[condition][]it is not true that_Rule {ruleID} multiple times_characterPreceededAndFollowedByAlphaNumeric with {field} in {section} and {char}=(characterPreceededAndFollowedByAlphaNumeric(xcb,{ruleID},{section},{field},{char}))
[condition][]it is not true that_Rule {ruleID} multiple times_position {pos1} and {pos2} of {field} in {section} is equal to values {values}=(Positions1n2Equals(xcb,{ruleID},{section},{field},{pos1},{pos2},{values}))
[condition][]Rule {ruleID} multiple times_the field {field} in {section} contain character {char} followed by space=(characterFollowedBySpace(xcb,{ruleID},{section},{field},{char}))
[condition][]Rule {ruleID} multiple times_the field {field} in {section} contains_single paranthesis and not contained in another parenthesis=(checkSingleParanthesis(xcb,{ruleID},{section},{field}))
[condition][]Rule {ruleID} multiple times_the {field1} in {section} is not_equal to the field {field2}=((multiNotEquals(xcb,{ruleID},{section},{field1},(xcb.xpath({field2}).stringValue()))))
[condition][]it is not true that_Rule {ruleID} multiple times_the {field} in {section} contains_ampersand preceded by a space=((isAmpersandprecspace(xcb,{ruleID},{section},{field})))
[condition][]Rule {ruleID} multiple times_the {field} in {section} contains_double virgule and not preceeded and followed by alphanumeric=((doubleVirgleNotPreceededAndFollowedByAlphaNumeric(xcb,{ruleID},{section},{field})))
[condition][]The_Rule {ruleID} multiple times {field} in {section} is populated=(xcb.moExists({ruleID},{section},{field}))
[condition][]The_Rule {ruleID} multiple times {field} in {section} is_not populated=(xcb.moNotExists({ruleID},{section},{field}))
[condition][]the field {field1} equals_to field {field2}=((new Equals()).isEquals(((xcb.xpath({field1})).stringValue()),((xcb.xpath({field2})).stringValue())))
[condition][]Any occurrence of {field} in {section} is equal to {values}=(EachOccOfFieldIsEqualValues(xcb,{section},{field},{values}))
[condition][]Any occurrence of {field} in {section} is_not equal to {values}=(EachOccOfFieldIsNotEqualValues(xcb,{section},{field},{values}))
[condition][]Rule {ruleID} multiple times {field1} in {section} field_is not equal to the_field {field2}=((multiNotEquals(xcb,{ruleID},{section},{field1},(xcb.xpath({field2}).stringValue()))))
[condition][]always true=eval(true)
[consequence][]Call_FieldValInSequence Function Set_with section {section} field {field} initail value {value} with errorcode {eCode} and errormsg {eMsg}=FieldValInSequence(xcb,{section},{field},{value},{eCode},{eMsg})
[consequence][]Call_LactOandIWithRTY Function Set_with section {section} field1 {field1} field2 {field2} field3 {field3} with errorcode {eCode} and errormsg {eMsg}=LactOandIWithRTY(xcb,{section},{field1},{field2},{field3},{eCode},{eMsg})
[consequence][]Call_CaptionSecMoreThan6 Function Set_with section {section} field {field} with errorcode {eCode} and errormsg {eMsg}=CaptionSecMoreThan6(xcb,{section},{field},{eCode},{eMsg})
[consequence][]Call_FieldIFieldNotO Function Set_with section {section} field1 {field1} field2 {field2} with errorcode {eCode} and errormsg {eMsg}=FieldIFieldNotO(xcb,{section},{field1},{field2},{eCode},{eMsg})
[consequence][]Call_FieldOFieldNotI Function Set_with section {section} field1 {field1} field2 {field2} with errorcode {eCode} and errormsg {eMsg}=FieldOFieldNotI(xcb,{section},{field1},{field2},{eCode},{eMsg})
[consequence][]Call_DeliveryInfoIsMoreThan2 Function Set_with section {section} field {field} with errorcode {eCode} and errormsg {eMsg}=DeliveryInfoIsMoreThan2(xcb,{section},{field},{eCode},{eMsg})
[consequence][]Call_EachOccOfAliAreSame Function Set_with section {section} field {field} with errorcode {eCode} and errormsg {eMsg}=EachOccOfAliAreSame(xcb,{section},{field},{eCode},{eMsg})
[consequence][]Call_EachOccOfRTYAreLML Function Set_with section {section} field {field} with errorcode {eCode} and errormsg {eMsg}=EachOccOfRTYAreLML(xcb,{section},{field},{eCode},{eMsg})
[consequence][]Call_FirstOccOfRTYIsNotLML Function Set_with section {section} field {field} with errorcode {eCode} and errormsg {eMsg}=FirstOccOfRTYIsNotLML(xcb,{section},{field},{eCode},{eMsg})
[consequence][]Call_LactIandOWithRTY Function Set_with section {section} field1 {field1} field2 {field2} field3 {field3} with errorcode {eCode} and errormsg {eMsg}=LactIandOWithRTY(xcb,{section},{field1},{field2},{field3},{eCode},{eMsg})
[consequence][]Call_LactOandIWithSameAli Function Set_with section {section} field1 {field1} field2 {field2} field3 {field3} with errorcode {eCode} and errormsg {eMsg}=LactOandIWithSameAli(xcb,{section},{field1},{field2},{field3},{eCode},{eMsg})
[consequence][]Call_LactIandOWithSameAli Function Set_with section {section} field1 {field1} field2 {field2} field3 {field3} with errorcode {eCode} and errormsg {eMsg}=LactIandOWithSameAli(xcb,{section},{field1},{field2},{field3},{eCode},{eMsg})
[consequence][]Call_SameAliWhenLactIandO Function Set_with section {section} field1 {field1} field2 {field2} field3 {field3} with errorcode {eCode} and errormsg {eMsg}=SameAliWhenLactIandO(xcb,{section},{field1},{field2},{field3},{eCode},{eMsg})
[consequence][]Call_SameRTYForEachLtnWithLact Function Set_with section {section} field1 {field1} field2 {field2} field3 {field3} with errorcode {eCode} and errormsg {eMsg}=SameRTYForEachLtnWithLact(xcb,{section},{field1},{field2},{field3},{eCode},{eMsg})
[consequence][]Call_SameLactForEachLtn Function Set_with section {section} field1 {field1} field2 {field2} field3 {field3} with errorcode {eCode} and errormsg {eMsg}=SameLactForEachLtn(xcb,{section},{field1},{field2},{field3},{eCode},{eMsg})
[consequence][]Call_LtnAndCkrAreNotSame Function Set_with section1 {section1} section2 {section2} field1 {field1} field2 {field2} with errorcode {eCode} and errormsg {eMsg}=LtnAndCkrAreNotSame(xcb,{section1},{section2},{field1},{field2},{eCode},{eMsg})
[consequence][]Call_SingleLocationSec Function Set_with section {section} with errorcode {eCode} and errormsg {eMsg}=SingleLocationSec(xcb,{section},{eCode},{eMsg})
[consequence][]Call_MaxTwoLocationSec Function Set_with section {section} with errorcode {eCode} and errormsg {eMsg}=MaxTwoLocationSec(xcb,{section},{eCode},{eMsg})
[consequence][]Call_MaxTwoLocationSecWithTos Function Set_with section {section} with errorcode {eCode} and errormsg {eMsg}=MaxTwoLocationSecWithTos(xcb,{section},{eCode},{eMsg})
[consequence][]Call_EccktShouldUnique Function Set_with section {section} with errorcode {eCode} and errormsg {eMsg}=EccktShouldUnique(xcb,{section},{eCode},{eMsg})
[consequence][]Call_PotssplitProhibited Function Set_with section {section} with errorcode {eCode} and errormsg {eMsg}=PotssplitProhibited(xcb,{section},{eCode},{eMsg})
[consequence][]Call_FieldShouldUnique Function Set_with section {section} field {field} with errorcode {eCode} and errormsg {eMsg}=FieldShouldUnique(xcb,{section},{field},{eCode},{eMsg})
[consequence][]Call_CkrShouldUnique Function Set_with section {section} with errorcode {eCode} and errormsg {eMsg}=CkrShouldUnique(xcb,{section},{eCode},{eMsg})
[consequence][]Call_FieldOccNotMoreThanCount Function Set_with section {section1} subsection {section2} field {field} value {value} with errorcode {eCode} and errormsg {eMsg}=FieldOccNotMoreThanCount(xcb,{section1},{section2},{field},{value},{eCode},{eMsg})
[consequence][]Call_ScaWithLnaNotEqualT Function Set_with section {section} field {field} with errorcode {eCode} and errormsg {eMsg}=ScaWithLnaNotEqualT(xcb,{section},{field},{eCode},{eMsg})
[consequence][]Call_Field1ValEqualNumOccOfField2 Function Set_with section {section} field1 {field1} field2 {field2} with errorcode {eCode} and errormsg {eMsg}=Field1ValEqualNumOccOfField2(xcb,{section},{field1},{field2},{eCode},{eMsg})
[consequence][]Call_noofoccurencesofrtyequalslml Function Set_with section {section} with errorcode {eCode} and errormsg {eMsg}=noofoccurencesofrtyequalslml(xcb,{section},{eCode},{eMsg})
[consequence][]Call_F1greaterThanF2 Function Set_with section {section} with errorcode {eCode} and errormsg {eMsg}=F1greaterThanF2(xcb,{section},{eCode},{eMsg})
[condition][]the {pos} position of {field} is_not_equals to {values}=((new Position()).positionOftagValueNotEqualToValue({pos},(xcb.xpath({field}).stringValue()),{values}))
[consequence][]Call_FieldShouldNotUnique Function Set_with section {section} field {field} with errorcode {eCode} and errormsg {eMsg}=FieldShouldNotUnique(xcb,{section},{field},{eCode},{eMsg})
[condition][]Rule {ruleID} multiple times_the {pos} position of {field} in {section} is_not_equals to_not_commaseparated_values {values}=((multiPosNotEquals(xcb,{ruleID},{section},{field},{pos},{values})))
[condition][]the field_tag {field} is exists=xcb.xpath({field}).booleanValue()
[condition][]the {field} is populated=((new Populated()).isPopulated((xcb.xpath({field})).stringValue()))
[condition][]the {field} is not populated=((new Populated()).isNotPopulated(xcb.xpath({field}).stringValue()))
[condition][]the {field} not_equals {value}=(((new Equals()).isNotEquals(((xcb.xpath({field})).stringValue()),{value})))

[condition][]Start Brace=(
[condition][]End Brace=)
[condition][]AND=&&
[condition][]OR=||
